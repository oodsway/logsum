#!/usr/bin/env bash

# -----------------------------------------------------------------------------
#   logsum: An Interactive Command-Line Interface Pilot's Logbook Summary Tool
#
#   Copyright (c) 2017
#   Author: Woods Wannamaker (woods.wannamaker@gmail.com)
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
# 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
# 
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 
# -----------------------------------------------------------------------------

clear

launch_path=$(pwd)
demo_logbook="${launch_path}"/logsum_demo.csv

if [ -e "$1" ]; then
    LOGBOOK_FILE="$1"
elif [ -e "$demo_logbook" ]; then
    LOGBOOK_FILE="$demo_logbook"
else
    printf "%s\n\n" "Source Logbook File Not Found! Exiting..."
    exit 1
fi

# DEFINITIONS:
EPOCH_LOG=/tmp/logbook_by_epoch.csv
OUTPUT_FILE=/tmp/logsum_results.txt
_SEC_IN_DAY=$((60 * 60 * 24))
default_ranges="30 60 90 180 365 1825 3650 7300" 
RECENT_RANGES=( $default_ranges )
is_sorted="chronological"
reg_text='[A-Za-z]'
reg_int='^[0-9]+$'
reg_int_range='(^[1-9]?$)|(^[^-0A-Za-z][0-9 ]+$)'
reg_float='^[0-9]+\.[0-9]+$'
reg_word_date='(D|d)(A|a)(T|t)(E|e)'

# SOURCE: https://redd.it/5gtilb
reg_date='([0-9]{2}(([02468][048])|([13579][26]))-((02-((0[1-9])|([12][0-9])))|((0[469]|11)-((0[1-9])|([12][0-9])|30))|((0[13578]|1[02])-((0[1-9])|([12][0-9])|3[01]))))|([0-9]{4}-((02-((0[1-9])|(1[0-9])|(2[0-8])))|((0[469]|11)-((0[1-9])|([12][0-9])|30))|((0[13578]|1[02])-((0[1-9])|([12][0-9])|3[01]))))'

function format_date () {
# Retruns the date format requested in $1

    case "$1" in
        as_epoch)
            date -d "$2" +%s
            ;;
        as_day)
            date -d @"$2" +%F
            ;;
        as_day_time)
            date +%F_%T
            ;;
        get_year)
            date -d @"$2" +%Y;;
    esac
    
return 0
}

function get_field_list () {
# Returns values for target_field in $1.

    awk -F, -v target_field="${1}" 'FNR>1 {print $target_field }' "$EPOCH_LOG"
    
return 0
}

function get_min_max () {
# Returns min and max values in a list.

    search_list=( "${@}" )
    min="${search_list[0]}"
    max="${search_list[0]}"
    
    for val in "${search_list[@]}"; do
        if [ "$val" -le "$min" ]; then
            min="$val"
        elif [ "$val" -ge "$max" ]; then
            max="$val"
        fi
    done
    echo "$min" "$max"

return 0
}

function epoch_engine () {
# Creates EPOCH_LOG with header from LOGBOOK_FILE source.

    printf "%s\n" "Creating the search database..."
    head -1 "$LOGBOOK_FILE" > "$EPOCH_LOG"
    # SOURCE: http://stackoverflow.com/questions/7965658/
    awk -F, '/19..|2.../{ OFS = FS;
    command="date -d" $1 " +%s";
    command | getline $1;
    close(command);
    print }' "$LOGBOOK_FILE" >> "$EPOCH_LOG"

    _EPOCH_NOW=$(date +%s)

    log_epoch_list=( $(get_field_list 1) )
    start_end=( $(get_min_max "${log_epoch_list[@]}") )
    log_start_epoch="${start_end[0]}"
    log_end_epoch="${start_end[1]}"
    
    log_start_date=$(format_date as_day "$log_start_epoch")
    log_end_date=$(format_date as_day "$log_end_epoch")
    printf "%s\n" "Search database creation completed."
    
return 0
}       

function leap_test () {
# Determines the number of leap days in a RECENT_RANGES epoch and corrects epoch accordingly.
# Returns an epoch unchanged or corrected for the number of leaps in the range.

    test_epoch="$1"
    year_test_epoch=$(format_date get_year "$test_epoch")
    year_epoch_now=$(format_date get_year "$_EPOCH_NOW")
    
    leaps=0
    for (( test_year="$year_epoch_now"; test_year>="$year_test_epoch"; test_year-- )); do
        if [[  "$test_year-02-29" =~ $reg_date ]]; then
            test_year_leap_day_epoch=$(format_date as_epoch "$test_year-02-29")
            
            if [[ "$_EPOCH_NOW" -ge "$test_year_leap_day_epoch" && "$test_epoch" -le "$test_year_leap_day_epoch" ]]; then
                let leaps leaps+=1
            fi
        fi
    done

    echo "$((test_epoch -  leaps * _SEC_IN_DAY))"
    
return 0
}

function build_epoch_list () {
# Calculate epoch_value for day-range & call leap_test.

    EPOCH_LIST=()
    for range in "${RECENT_RANGES[@]}"; do
        leap_tested_epoch=$( leap_test $((_EPOCH_NOW - range * _SEC_IN_DAY )) )
        EPOCH_LIST+=( "$leap_tested_epoch" )
    done
    
return 0
}

function field_type_test () {
# awk of selected field is pipped to grep which checks results vs regex for text
# then counts and returns the number found (>0 is text; =0 is a number).

    awk -F, -v fld="$1" 'FNR>1 {print $fld}' "$EPOCH_LOG" | grep -Ec "$2"
    
return 0
}

function category_summary () {
# Prints a summary table of experience by category. Also builds search_field_index_list
# and fields_list that are used later. Uses field_type_test function to determine if field
# type is text,integer, or float. Date field (an integer) is excluded by using reg_word_date.

    fields_list=()
    text_field_index_list=()
    float_field_index_list=()
    int_field_index_list=()
    search_field_index_list=()
    
    # get the number of data fields in the file header.
    len=$(head -1 "$EPOCH_LOG" | awk -F, '{print NF}')
    local seperator="--------------------------------------"
    {
    printf " %-28s %-9s\n" "Category" "Totals"
    printf "%s\n" "$seperator"

    for (( i=1; i<=len; i++ )); do
        field_sum=$(awk -F, -v fld="$i" '{ {sum+=$fld} } END {print sum}' "$EPOCH_LOG")
        field_name=$(head -1 "$EPOCH_LOG" | awk -F, -v fld="$i" '{print $fld}' | sed 's/[^ ]\+/\L\u&/g' | sed 's/\r$//g')
        fields_list+=( "${field_name}" )

        is_text=$(field_type_test "$i" "$reg_text")
        is_float=$(field_type_test "$i" "$reg_float")
        is_int=$(field_type_test "$i" "$reg_int")
        
        if [[ "$is_text" -gt 0 ]]; then        
            text_field_index_list+=( "$i" )        
        elif [[ "$is_float" -gt 0 && ! "$field_name" =~ $reg_word_date ]]; then
            printf ' %-25s    %6.1f\n' "${fields_list[$i-1]} " " $field_sum"
            float_field_index_list+=( "$i" )
            search_field_index_list+=( "$i" )        
        elif [[ "$is_int" -ge 0 && ! "$field_name" =~ $reg_word_date ]]; then
            printf ' %-25s    %6d\n' "${fields_list[$i-1]} " " $field_sum"
            int_field_index_list+=( "$i" )
            search_field_index_list+=( "$i" )        
        fi
    done
    printf "%s\n\n" "$seperator"
    } >> "$OUTPUT_FILE"
    
return 0
}

function display_data_fields () {
# Displays tables of field information and leap-corrected dates. Development tool.

    local seperator="-------------------------------------------------------------"
    {
    printf "%s %s\n\n" "Current Logbook Source File: " "$LOGBOOK_FILE"
    printf "%-26s %-15s %-15s\n" "field_name"  "field_index #" "array_index #"
    printf "%s\n" "$seperator"
    
    for i in "${!fields_list[@]}"; do
        printf " %-30s %-15s %-15s\n" "${fields_list[$i]}" "$((i+1))" "$i" 
    done
    
    printf "%s\n" "$seperator"
    printf "%s %s\n" "Fields in use: " "${search_field_index_list[*]}"      
    printf "%s %s\n" "Text fields:" "${text_field_index_list[*]}" 
    printf "%s %s\n" "Float fields: " "${float_field_index_list[*]}" 
    printf "%s %s\n\n\n" "Integer fields: " "${int_field_index_list[*]}"
    
    local seperator="--------------------------------------"   
    printf "%s\n" "Current Search Start Date: $(format_date as_day "$_EPOCH_NOW")"
    printf "%-20s %-10s\n" " Recent Range" "Start Date"
    printf "%s\n" "$seperator"
    for i in "${!RECENT_RANGES[@]}"; do 
        printf "   %-17s %-12s\n" "${RECENT_RANGES[$i]}" "$(format_date as_day "${EPOCH_LIST[$i]}")"
    done
    printf "%s\n\n" "$seperator"
    } >> $OUTPUT_FILE
    
return 0
}

function get_array_sum () {
# Calculates the sum of int or float values in an array.

    echo "${@}" | tr ' ' '\n' | awk '{sum+=$1} END {print sum}'
    
return 0
}

function get_epoch_range_sum () {
# Calculates the sum for a given field between two epoch values then & now.

    awk -F, -v now="$1" -v then="$2" -v field="$3" '{if ($1>=then && $1<=now) {s+=$field} } END {print s}' "$EPOCH_LOG"

return 0
}

function list_sorter () {
# Returns unique sorted (A-z) || unique unsorted (chrono if csv by date) values 
# for target_field dependent on status of is_sorted flag.

    if [[ "$is_sorted" = "alphabetical" ]]; then
        sort -u
   else
        # SOURCE: http://stackoverflow.com/questions/618378/
        perl -ne 'if (!defined $x{$_}) { print $_; $x{$_} = 1; }'
    fi
    
return 0
}

function table_seperator () {
# Prints a variable-length line seperator dependent on the length of RECENT_RANGES array.

    local seperator="--------"
    printf "%s" "-------------------------------"
    for ((i=0; i<=${#RECENT_RANGES[@]}-1; i++)); do 
        printf "%s" "$seperator"
    done
    printf "\n"
    
return 0
}

function flight_experience_summary () {
# Creates summary table of total and recent flight experience.

    max_recent_experience_date=$(format_date as_day "${EPOCH_LIST[*]: -1}")
    epoch_now_date=$(format_date as_day "$_EPOCH_NOW")
    {
    printf "%-45s %-45s\n" "Total Flight Experience"  "Recent Flight Experience"
    printf "%-45s %-45s\n" "From: $log_start_date" "From: $epoch_now_date"   
    printf "%-45s %-45s\n\n" "Thru: $epoch_now_date" "Thru: $max_recent_experience_date"     
    printf "%-22s %-9s" "Category" "Totals"
    
    # This loop prints RECENT_RANGES values with spacing followed by label.
    for i in "${!RECENT_RANGES[@]}"; do
        printf "   %s " "${RECENT_RANGES[$i]}"
    done
    printf "days\n"
    table_seperator
    
    for index in "${search_field_index_list[@]}"; do
        field_name="${fields_list[index-1]}"
        field_sum=$(get_epoch_range_sum "$_EPOCH_NOW" "$log_start_epoch" "$index")
 
        # Determine bounds & the recent_experience value then add to recent_exp_list.
        for search_epoch in "${EPOCH_LIST[@]}"; do
            if [[ "$search_epoch" -gt "$log_end_epoch" || "$_EPOCH_NOW" -lt "$log_start_epoch" ]]; then            
                value=0
            else
                value=$(get_epoch_range_sum "$_EPOCH_NOW" "$search_epoch" "$index")
                if [ "$value" = "" ]; then value=0; fi
            fi
            recent_exp_list+=( "$value"  )                                    
        done

        # Conditional to print using either integers or float format.       
        if [[ "$field_sum" =~ $reg_int ]]; then
            printf "%-22s %6s| " "${field_name} " "$field_sum"  
        elif [[ "$field_sum" =~ $reg_float ]]; then
            printf "%-22s %6.1f| " "${field_name} " "$field_sum"
        fi    
                      
        # This loop prints recent_exp_list in correct format.       
        for i in "${!recent_exp_list[@]}"; do
            if [[ $i -eq ${#recent_exp_list[@]}-1 ]]; then
                printf " %7s\n" "${recent_exp_list[$i]}"
            else
                printf " %5s|" "${recent_exp_list[$i]}"
            fi
        done           
       unset recent_exp_list   
    done
            
    table_seperator
    printf "%s\n" "Current Search Start Date: $epoch_now_date"
    printf "%s\n\n" "Last Recorded Flight Date: $log_end_date"
    } >> $OUTPUT_FILE
    
return 0
}

function aircraft_type_summary () {
# Creates summary table of flight experience by aircraft type with list of aircraft IDs for each type.

    AIRCRAFT_TYPE_LIST=( $(get_field_list 2 | list_sorter ) )
    local seperator="--------------------------------------------------------------------------------"
    {
    printf "%s\n" " Aircraft Type        Aircraft IDs                               Flight Time (h)"
    printf "%s\n" "$seperator"
    
    type_times=( )
    for aircraft_type in "${AIRCRAFT_TYPE_LIST[@]}"; do
        ac_type_id_list=( $(awk -F, -v val="${aircraft_type}" '{ if ($2==val) {print $3} }' "$EPOCH_LOG" | list_sorter) )
        time_in_type=$(awk -F, -v val="${aircraft_type}" -v fld="6" '{ if ($2==val) {s+=$fld} } END {print s}' "$EPOCH_LOG")

        # If duration/time (field 6) is 0, check if simulator (field 13).      
        if [ "$time_in_type" = 0 ]; then
            time_in_type=$(awk -F, -v val="${aircraft_type}" -v fld="13" '{ if ($2==val) {s+=$fld} } END {print s}' "$EPOCH_LOG")
        fi
        # Print ac_type_id_list: wrap if number elements >5; if <5 print on same line
        if [[ "${#ac_type_id_list[@]}" -gt 5 ]] ; then
            printf " %-20s %-45s %6.1f\n" "${aircraft_type}" "${ac_type_id_list[*]:0:5}"  "$time_in_type"
            
            for ((i=6; i<="${#ac_type_id_list[@]}"; i++)); do
                mod=$(( i % 5 ))
                if [ "$mod" -eq 0 ]; then
                    printf "%s\n" "${ac_type_id_list[$i-1]}"
                else
                    if [ "$mod" -eq 1 ]; then
                        printf "%-22s" " "
                    fi
                    printf "%s "  "${ac_type_id_list[$i-1]}"
                fi
            done
        printf "\n\n"
            
        else
            printf " %-20s %-45s %6.1f\n" "${aircraft_type}" "${ac_type_id_list[*]}"  "$time_in_type"
        fi
      
        type_times+=( "$time_in_type"  )
    done
    types_sum=$(get_array_sum "${type_times[*]}")
    
    printf "%s\n" "$seperator"
    printf " %s %67.1f\n" "Total" "$types_sum"
    printf " %s\n\n" "Results are $is_sorted"
    } >> $OUTPUT_FILE
    
return 0
}

function aircraft_id_summary () {
# Creates summary table of flight experience by aircraft ID including aircraft type.

    AIRCRAFT_ID_LIST=( $(get_field_list 3 | list_sorter) ) 
    local seperator="-------------------------------------------------------"
    {
    printf "%s\n" " Aircraft ID       Aircraft Type      Flight Time (h)"
    printf "%s\n" "$seperator"

    id_times=( )
    for aircraft_id in "${AIRCRAFT_ID_LIST[@]}"; do
        type_ac_id=$(awk -F, -v val="$aircraft_id" '{ if ($3==val) {print $2} }' "$EPOCH_LOG" | list_sorter)
        time_in_id=$(awk -F, -v val="$aircraft_id" -v fld="6" '{ if ($3==val) {s+=$fld} } END {print s}' "$EPOCH_LOG")
        # if time_in_id (field 6) is 0, check if simulator time (field 13)
        if [ "$time_in_id" == 0 ]; then
            time_in_id=$(awk -F, -v val="$aircraft_id" -v fld="13" '{ if ($3==val) {s+=$fld} } END {print s}' "$EPOCH_LOG")
        fi   
        id_times+=( "$time_in_id"  )        
        printf "  %-17s %-19s %6.1f\n" "$aircraft_id" "$type_ac_id" "$time_in_id"
    done
    by_id_sum=$(get_array_sum "${id_times[*]}")
    
    printf "%s\n" "$seperator"
    printf " %s %39.1f\n" "Total" "$by_id_sum"
    printf " %s\n\n" "Results are $is_sorted"
    } >> $OUTPUT_FILE
    
return 0
}

function experience_by_year () {
# Creates summary table of flight experience by year.

    local seperator="------------------------"
    {
    printf "%23s\n" "Year | Flight Time (h)"
    printf "%s\n" "$seperator"
    
    a="$(format_date get_year "$log_start_epoch")"
    z="$(format_date get_year "$log_end_epoch")"
    
    # Loop because brace expansion with variables fails in bash.
    years=( )
    for (( i=a; i<=z; i++ )); do  
        years+=("$i")
    done
    
    by_year_sums=( )
    for year in "${years[@]}"; do
        start_year_epoch=$(format_date as_epoch "$year-01-01")
        end_year_epoch=$(format_date as_epoch "$year-12-31")
        year_sum=$(get_epoch_range_sum "$end_year_epoch" "$start_year_epoch"  6)   
        by_year_sums+=( "$year_sum" )        
        printf "%5s | %9.1f \n"  "$year" "$year_sum"
    done
    by_year_total=$(get_array_sum "${by_year_sums[*]}")
    
    printf "%s\n" "$seperator"
    printf "%s %11.1f\n\n" "Total" "$by_year_total"
    } >> $OUTPUT_FILE
    
return 0
}

function change_date () {
# Sets a new start date & rebuilds the EPOCH_LIST.

    printf "%s\n" "Current Search Start Date: $(format_date as_day "$_EPOCH_NOW")"
    printf "%s\n\n" "Last Recorded Flight Date: $log_end_date"

    while true; do
        read -r -p "Enter YYYY-MM-DD | (t)oday | (l)ast flight date | enter to cancel: " new_date
        case $new_date in
        "") printf "%s\n\n" "Returning to main menu"
            return 0
            ;;
        "t") _EPOCH_NOW=$(date +%s)
            printf "%s\n\n" "New Search Start Date: $(format_date as_day "$_EPOCH_NOW")"
            break
            ;;
        "l") _EPOCH_NOW="$log_end_epoch"
            printf "%s\n\n" "New Search Start Date: $log_end_date"
            break      
            ;;           
        *)  if [[ "$new_date" =~ $reg_date ]]; then
                _EPOCH_NOW=$(format_date as_epoch "$new_date")
                printf "%s\n\n" "New Search Start Date: $new_date"
                break
            else
                printf "%s\n\n" "Invalid date or format!"
            fi
            ;;              
        esac
    done
    build_epoch_list
    
return 0
}

function sort_custom_ranges () {
# Sorts custom RECENT_RANGES values from low to high (most recent 1st; oldest last).

    copy_list=( "${@}" )
    sorted_list=()
    
    # pick first item in list then check to find true min & add that to sorted_list   
    min="${copy_list[0]}"
    
    while (( ${#copy_list[@]} > 0)); do
        min_max=( $(get_min_max "${copy_list[@]}") )
        min="${min_max[0]}"
        sorted_list+=( "$min" )
        
        # remove min from copy_list by making tmp_list excluding min; make copy==new and reset min.       
        tmp_list=()
        for val in "${copy_list[@]}"; do
            if [ "$val" != "$min" ]; then
                tmp_list+=( "$val" )
            fi
        done    
        copy_list=( "${tmp_list[@]}" )
        min="${copy_list[0]}"
    done
    
    echo "${sorted_list[@]}"
    
return 0
}

function change_recent_ranges () {
# Sets custom recent experience ranges & rebuilds the EPOCH_LIST.

    printf "%s\n\n" "Current range(s): ${RECENT_RANGES[*]}"    
    while true; do
        read -r -p "Enter values separated by spaces | (d)efault ranges | enter to cancel: " line
        
        case $line in
            "") printf "%s\n\n" "Returning to main menu"
                return 0
                ;;
            "d") RECENT_RANGES=( $default_ranges )
                break
                ;;
                # check if integer(s) separated with spaces
            *)  if [[ "$line" =~ $reg_int_range ]]; then
                    new_ranges=( $line )   
                    RECENT_RANGES=( $(sort_custom_ranges "${new_ranges[@]}" ) )
                    break
                else
                    printf "%s\n\n" "Invalid ranges format!"
                fi
                ;;
        esac
    done
    printf "%s\n\n" "Current range(s): ${RECENT_RANGES[*]}"   
    build_epoch_list
    
return 0
}

function display_results () {
# Sends OUTPUT_FILE and menu to stdout.

    clear
    cat $OUTPUT_FILE
    menu
    
return 0
}

function save_to_file () {
# Saves OUTPUT_FILE results to file in launch directory.

    report_file="$launch_path/logbook_report_$(format_date as_day_time).txt"
    printf "%s\n\n" "Report created: $(date)" > "$report_file"    
    cat $OUTPUT_FILE >> "$report_file"
    printf "%s\n\n" "Results saved to:$report_file"
    
return 0
}

function import_log_file () {
# Import a new logbook file;  re-build EPOCH_LOG, EPOCH_LIST & field lists.

    printf "%s %s\n" "Current logfile is: " "$LOGBOOK_FILE"
    while true; do
        read -r -p "Enter Filename or press Enter to cancel: " new_db
        
        case $new_db in
            "") printf "%s\n\n" "Returning to main menu"
                return 0
                ;;
            *)  if [ -e "$new_db" ]; then
                    LOGBOOK_FILE="${launch_path}"/"$new_db"
                    printf "%s %s\n" "New logfile is: " "$LOGBOOK_FILE"
                    RECENT_RANGES=( $default_ranges )
                    create_search_database
                    break
                else
                    printf "%s\n\n" "File not found! Check filename."
                fi
                ;;
        esac
    done
    
return 0
}

function toggle_sort_status () {
# Toggles status of is_sorted variable.

    if [[ "$is_sorted" = "alphabetical" ]]; then
        is_sorted="chronological"
    else
        is_sorted="alphabetical"
    fi
    printf "%s\n" "Aircraft Type & Aircraft ID results will appear $is_sorted."
    
return 0
}

function help_file () {
# Displays the help.txt file or error if not found.

    if [ -e help.txt ]; then
        clear
        more help.txt
    else
        printf "%s\n\n" "Help file not found!"
    fi
    
return 0
}

function display_license () {
# Displays the LICENSE.txt file or error if not found.

    if [ -e LICENSE.txt ]; then
        clear
        more LICENSE.txt
    else
        printf "%s\n\n" "LICENSE file not found!"
    fi
    
return 0
}

function startup_notice () {
# Displays the program warranty and license notice at startup.

cat << 'EOF'
    logsum  Copyright (c) 2017  Woods Wannamaker (woods.wannamaker@gmail.com)
    
    This program comes with ABSOLUTELY NO WARRANTY. This is free software 
    and you are welcome to redistribute it and/or modify it under certain 
    conditions; select menu option [L] for license details.
    
EOF

return 0
}

function menu () {
# Displays the full menu at start or menu choices between functions.

local seperator="--------------------------------------------------------------------------------"
if [ "$1" = "start" ]; then
    printf "%s\n"   "$seperator"
    printf "%s\n"   "                            Pilot's Logbook Summary Menu"
    printf "%s\n"   "$seperator"
fi

cat << 'EOF'
    [1]  Total & Recent Experience Table        [s]  Save Results to File
    [2]  Experience by Category                 [i]  Import a New Logbook File
    [3]  Experience by Aircraft Type            [d]  Display Database Fields
    [4]  Experience by Aircraft ID              [t]  Toggle Sort Method
    [5]  Experience by Year                     [m]  Menu
    [6]  Display All (1-5)                      [h]  Help
    [7]  Custom Search Start Date               [L]  License
    [8]  Custom Recent Experience Ranges        [q]  Quit

EOF

return 0
}

function create_search_database () {
# Calls functions that initialize the search database.

    epoch_engine
    build_epoch_list
    category_summary
    
return 0
}

function main () {
# Interactive program control.

create_search_database
clear
menu start
startup_notice

menu_item_list=( 1 2 3 4 5 6 d )
while true; do
    read -r -p "Enter Selection: " opt
    if ( echo "${menu_item_list[@]}" | grep -Eq "$opt" ); then
        rm -f $OUTPUT_FILE
    fi        
    case $opt in
        "1")flight_experience_summary
            display_results
            ;;
        "2")category_summary
            display_results
            ;;
        "3")aircraft_type_summary
            display_results
            ;;
        "4") aircraft_id_summary
            display_results
            ;;
        "5")experience_by_year
            display_results
            ;;
        "6")flight_experience_summary
            category_summary
            aircraft_type_summary
            aircraft_id_summary
            experience_by_year
            display_results
            ;;
        "7")change_date
            ;;
        "8")change_recent_ranges
            ;;
        "s")save_to_file
            ;;
        "i")import_log_file
            ;; 
        "d")display_data_fields
            display_results
            ;;
        "t") toggle_sort_status
            ;;
        "m") clear; menu start
            ;;
        "h") help_file
            ;;
        "L") clear; display_license
            ;;
        "q")break
            ;;
        *) printf "%s\n\n" "Invalid option!"
            ;;
    esac
done
rm -f $OUTPUT_FILE

return 0
} 

clear
main
